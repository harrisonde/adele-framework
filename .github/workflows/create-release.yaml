name: create release workflow

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  release:
    env:
      BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
    runs-on: ["self-hosted", "macOS", "ARM64", "cidekar", "macos-arm64"]
    if: github.event.pull_request.merged == true
    steps:
      - name: validate is a release pr
        id: check_release
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "PR Title: $PR_TITLE"

          # Pattern to match "Auto Release PR: v{semver}rc"
          RC_PATTERN="Auto Release PR: (v?[0-9]+\.[0-9]+\.[0-9]+)(-rc(\.[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?)"

          if [[ "$PR_TITLE" =~ $RC_PATTERN ]]; then
            # Extract the base version (without any -rc suffix)
            BASE_VERSION="${BASH_REMATCH[1]}"

            # Extract the full RC tag (base + rc suffix)
            RC_SUFFIX="${BASH_REMATCH[2]}"
            RC_TAG="${BASE_VERSION}${RC_SUFFIX}"

            echo "RC tag extracted: $RC_TAG"
            echo "Clean tag (without rc): $BASE_VERSION"

            echo "is_release_pr=true" >> $GITHUB_OUTPUT
            echo "rc_tag=$RC_TAG" >> $GITHUB_OUTPUT
            echo "clean_tag=$BASE_VERSION" >> $GITHUB_OUTPUT
            echo "This is a release RC PR - proceeding with workflow"
          else
            echo "is_release_pr=false" >> $GITHUB_OUTPUT
            echo "This is not a release RC PR - skipping workflow"
          fi

      - name: checkout the repository
        if: steps.check_release.outputs.is_release_pr == 'true'
        uses: actions/checkout@v4

      - name: create clean release tag
        if: steps.check_release.outputs.is_release_pr == 'true'
        run: |
          echo "Creating clean release tag: ${{ steps.check_release.outputs.clean_tag }}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Switch to base branch safely
          echo "Switching to base branch: $BASE_BRANCH"
          git fetch origin $BASE_BRANCH

          if git checkout $BASE_BRANCH; then
            echo "✅ Successfully checked out $BASE_BRANCH"
            git pull origin $BASE_BRANCH
          else
            echo "❌ Failed to checkout $BASE_BRANCH"
            exit 1
          fi

          # Create and push the clean tag
          git tag ${{ steps.check_release.outputs.clean_tag }}
          git push origin ${{ steps.check_release.outputs.clean_tag }}

          echo "✅ Clean tag ${{ steps.check_release.outputs.clean_tag }} created successfully"

      - name: add go (production)
        uses: actions/setup-go@v5
        if: ${{ !env.ACT }}
        with:
          go-version: '1.23.4'
          cache: false
        env:
          GOPROXY: "https://proxy.golang.org,direct"

      - name: add go (testing)
        if: ${{ env.ACT }}
        run: |
          echo "Checking for Go installation..."

          if command -v go &> /dev/null; then
            echo "✅ Go already available: $(go version)"
          else
            echo "Installing Go without package manager..."

            # Create directory in user space (no sudo needed)
            mkdir -p $HOME/go-install
            cd $HOME/go-install

            # Download Go using curl (more likely to be available than wget)
            if command -v curl &> /dev/null; then
              echo "Downloading Go 1.21.5..."
              curl -sL https://go.dev/dl/go1.21.5.linux-amd64.tar.gz -o go.tar.gz

              # Extract to home directory (no root needed)
              tar -xzf go.tar.gz

              # Set up paths
              export GOROOT="$HOME/go-install/go"
              export PATH="$GOROOT/bin:$PATH"
              echo "$GOROOT/bin" >> $GITHUB_PATH

              echo "✅ Go installed to: $GOROOT"
            else
              echo "❌ curl not available, cannot install Go"
              exit 1
            fi
          fi

          # Final verification
          echo "Go version check:"
          go version

          # Set directories
          mkdir -p /github/workspace/.gocache
          mkdir -p /github/workspace/.gotmp
          chmod -R 777 /github/workspace/.gocache /github/workspace/.gotmp

      - name: write version tag from release
        run: |
          GITHUB_REF_TAG=${{ steps.check_release.outputs.clean_tag }} go run .github/workflows/semantic-release-write-version.go
          cat adele.go | grep  "const Version*"
          echo "✅ Version tag written to source code"

      - name: commit source code
        env:
            IS_ACT: ${{ env.ACT || 'false' }}
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN}}
        run: |
          if [ "$IS_ACT" = "true" ]; then
            mkdir -p ~/.ssh
            ssh-keyscan -H github.com >> ~/.ssh/known_hosts
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{secrets.GITHUB_USER}}/adele-framework.git
          fi

          if git diff --cached --quiet && git diff --quiet; then
            echo "✅ No changes to commit"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git commit -a -m "write version tag ${{ steps.check_release.outputs.clean_tag }} to source code"
            git push
            echo "✅ Git commit completed successfully"
          fi

      - name: install quill
        run: curl -sSfL https://raw.githubusercontent.com/anchore/quill/main/install.sh | sh -s -- -b .tmp/quill v0.4.1

      - name: run goreleaser
        if: steps.check_release.outputs.is_release_pr == 'true'
        run: |
          echo "=== GoReleaser Environment ==="
          echo "GOSUMDB: '$GOSUMDB'"
          echo "GOPROXY: '$GOPROXY'"
          go env GOSUMDB
          go env GOPROXY
          echo ""

          if ! command -v goreleaser &> /dev/null; then
            echo "Installing GoReleaser..."
            go install github.com/goreleaser/goreleaser@latest
            echo "✅ GoReleaser installed"
          else
            echo "✅ GoReleaser already available"
          fi
          echo "Release PR merged detected! Running release workflow..."
          goreleaser release --clean --skip-validate
          echo "✅ Release completed!"
        env:
          GOSUMDB: "sum.golang.org"
          GOPROXY: "https://proxy.golang.org,direct"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Certificate Type: Developer ID Application
          # Base64 encoded contents or path to signing private key and certificate from Apple (this is in the form of a ".p12" file)
          QUILL_SIGN_P12: ${{ secrets.QUILL_SIGN_P12 }}
          QUILL_SIGN_PASSWORD: ${{ secrets.QUILL_SIGN_PASSWORD }}
          # App store connect team API Key with App Manager scope
          # The .p8 key file path or its base64'd contents.
          QUILL_NOTARY_KEY: ${{ secrets.QUILL_NOTARY_KEY }}
          # The issuer ID.
          # Its the UUID you see when creating the App Store Connect key.
          QUILL_NOTARY_KEY_ID: ${{ secrets.QUILL_NOTARY_KEY_ID }}
          # The issuer ID.
          # Its the UUID you see when creating the App Store Connect key.
          QUILL_NOTARY_ISSUER: ${{ secrets.QUILL_NOTARY_ISSUER }}

      - name: clean go cache
        run: |
          go clean -modcache
          go clean -cache
