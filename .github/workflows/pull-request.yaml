name: create pr workflow
on:
  push:
    tags:
      - '*rc'
      # - '[0-9]+.[0-9]+.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?'
jobs:
  release:
    runs-on: ["self-hosted", "macOS", "ARM64", "cidekar", "macos-arm64"]
    steps:
      - name: install github CLI
        run: |
          # Check if already installed
          if command -v gh &> /dev/null; then
            echo "GitHub CLI already available: $(gh --version)"
            exit 0
          fi

          echo "Installing GitHub CLI via direct download..."

          # Use latest version or specify a known working version
          GH_VERSION="2.62.0"

          # Detect platform and architecture
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)

          # Map architecture names to GitHub CLI conventions
          case $ARCH in
            x86_64) GH_ARCH="amd64" ;;
            aarch64) GH_ARCH="arm64" ;;
            arm64) GH_ARCH="arm64" ;;
            *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
          esac

          # Set correct filename format based on OS
          case $OS in
            linux)
              FILENAME="gh_${GH_VERSION}_linux_${GH_ARCH}.tar.gz"
              EXTRACT_CMD="tar -xzf"
              ;;
            darwin)
              # macOS uses .zip format, not .tar.gz
              FILENAME="gh_${GH_VERSION}_macOS_${GH_ARCH}.zip"
              EXTRACT_CMD="unzip -q"
              ;;
            *) echo "Unsupported OS: $OS"; exit 1 ;;
          esac

          DOWNLOAD_URL="https://github.com/cli/cli/releases/download/v${GH_VERSION}/${FILENAME}"

          echo "Downloading: $DOWNLOAD_URL"

          # Create temp directory
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"

          # Download
          curl -fsSL "$DOWNLOAD_URL" -o "gh_archive" || {
            echo "Failed to download GitHub CLI from $DOWNLOAD_URL"
            echo "File might not exist. Checking available releases..."
            curl -s "https://api.github.com/repos/cli/cli/releases/latest" | grep "browser_download_url" | grep -E "(macOS|linux)" | head -5
            exit 1
          }

          # Extract based on file type
          $EXTRACT_CMD gh_archive || {
            echo "Failed to extract archive"
            exit 1
          }

          # The extracted directory should match the filename (without extension)
          case $OS in
            linux)
              EXTRACTED_DIR="gh_${GH_VERSION}_linux_${GH_ARCH}"
              ;;
            darwin)
              EXTRACTED_DIR="gh_${GH_VERSION}_macOS_${GH_ARCH}"
              ;;
          esac

          # Verify the extracted directory exists
          if [ ! -d "$EXTRACTED_DIR" ]; then
            echo "Expected directory $EXTRACTED_DIR not found. Contents:"
            ls -la
            exit 1
          fi

          # Install the binary
          if [ -w /usr/local/bin ] 2>/dev/null; then
            cp "${EXTRACTED_DIR}/bin/gh" /usr/local/bin/gh
            chmod +x /usr/local/bin/gh
            echo "Installed to /usr/local/bin/gh"
          else
            # Install to user directory
            mkdir -p "$HOME/bin"
            cp "${EXTRACTED_DIR}/bin/gh" "$HOME/bin/gh"
            chmod +x "$HOME/bin/gh"
            echo "$HOME/bin" >> $GITHUB_PATH
            export PATH="$HOME/bin:$PATH"
            echo "Installed to $HOME/bin/gh"
          fi

          # Cleanup
          cd /
          rm -rf "$TEMP_DIR"

          # Verify installation
          if command -v gh &> /dev/null; then
            echo "✅ GitHub CLI installed successfully: $(gh --version)"
          else
            echo "❌ GitHub CLI installation failed"
            exit 1
          fi


      - name: add go (production)
        uses: actions/setup-go@v5
        if: ${{ !env.ACT }}
        with:
          go-version: '1.21'

      - name: add go (testing)
        if: ${{ env.ACT }}
        run: |
          echo "Checking for Go installation..."

          if command -v go &> /dev/null; then
            echo "✅ Go already available: $(go version)"
          else
            echo "Installing Go without package manager..."

            # Create directory in user space (no sudo needed)
            mkdir -p $HOME/go-install
            cd $HOME/go-install

            # Download Go using curl (more likely to be available than wget)
            if command -v curl &> /dev/null; then
              echo "Downloading Go 1.21.5..."
              curl -sL https://go.dev/dl/go1.21.5.linux-amd64.tar.gz -o go.tar.gz

              # Extract to home directory (no root needed)
              tar -xzf go.tar.gz

              # Set up paths
              export GOROOT="$HOME/go-install/go"
              export PATH="$GOROOT/bin:$PATH"
              echo "$GOROOT/bin" >> $GITHUB_PATH

              echo "✅ Go installed to: $GOROOT"
            else
              echo "❌ curl not available, cannot install Go"
              exit 1
            fi
          fi

          # Final verification
          echo "Go version check:"
          go version

      - name: setup go directories for act
        if: ${{ env.ACT }}
        run: |
          mkdir -p /github/workspace/.gocache
          mkdir -p /github/workspace/.gotmp
          chmod -R 777 /github/workspace/.gocache /github/workspace/.gotmp

      - name: checkout the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: extract version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: create release branch
        env:
          IS_ACT: ${{ env.ACT || 'false' }}
        run: |
          if [ "$IS_ACT" = "true" ]; then
            mkdir -p ~/.ssh
            ssh-keyscan -H github.com >> ~/.ssh/known_hosts
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{secrets.GITHUB_USER}}/adele-framework.git
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b release/${{ steps.version.outputs.VERSION }}
          git push origin release/${{ steps.version.outputs.VERSION }}

      - name: write version tag from release
        run: |
          GITHUB_REF_TAG=${{ steps.version.outputs.VERSION }} go run .github/workflows/semantic-release-write-version.go
          cat adele.go | grep  "const Version*"
          echo "✅ Version tag written to code"

      - name: commit source code
        env:
            IS_ACT: ${{ env.ACT || 'false' }}
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN}}
        run: |
          if [ "$IS_ACT" = "true" ]; then
            mkdir -p ~/.ssh
            ssh-keyscan -H github.com >> ~/.ssh/known_hosts
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{secrets.GITHUB_USER}}/adele-framework.git
          fi

          if git diff --cached --quiet && git diff --quiet; then
            echo "✅ No changes to commit"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git checkout release/${{ steps.version.outputs.VERSION }}
            git commit -a -m "continuous integration build artifacts ${{ steps.version.outputs.VERSION }}"
            git push origin release/${{ steps.version.outputs.VERSION }}
            echo "✅ Git commit completed successfully"
          fi

      - name: create pr from workflow release branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ACTOR_NAME: ${{ env.GITHUB_ACTOR || github.actor }}
        run: |
          SOURCE_BRANCH="release/${{ steps.version.outputs.VERSION }}"

          gh repo set-default ${{ github.repository }}

          if [[ "${ACTOR_NAME}" != "nektos/act" ]] && [[ -n "${ACTOR_NAME}" ]]; then
            ASSIGNEE_FLAG="--assignee ${ACTOR_NAME}"
            echo "Using assignee: ${ACTOR_NAME}"
          else
            ASSIGNEE_FLAG=""
            echo "Skipping assignee (act mode or invalid user)"
          fi

          gh pr create \
            --title "Auto Release PR: ${{ github.ref_name }}" \
            --body "## Summary
          This is an automatically generated pull request by github-actions[bot]

          ### Changes
          - Auto-generated from branch: \`${SOURCE_BRANCH}\`
          - Triggered by: ${{ github.event_name }}
          - Tag: ${{ steps.version.outputs.VERSION }}

          ### Checklist
          - [ ] Code review completed
          - [ ] Tests passing
          - [ ] Documentation updated

          ---
          *This PR was created automatically by GitHub Actions*" \
            --head "${SOURCE_BRANCH}" \
            --base "main-test" \
            --label "automated,needs-review" \
            ${ASSIGNEE_FLAG}

          echo "✅ PR created for ${SOURCE_BRANCH} → main"
